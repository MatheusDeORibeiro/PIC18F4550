/*
 * Nome do arquivo:    teste_nokia_5110.c
 * Data:               31/08/2022
 * Versão:             1.0
 * MPLAB X IDE:        v5.45
 * Autor:              Matheus de Oliveira Ribeiro
 */


#include <xc.h>
#include "nokia_5110.h" //inclui a biblioteca de funções para o diplay Nokia 5110
#include "spi.h"        //inclui a biblioteca de funções no módulo MSSP para comunicação SPI
#include "configuracao_pic18f4550.h" //inclui configurações do PIC18F4550

#define _XTAL_FREQ 20000000 //Fosc = 20MHz -> Tciclo = 4/Fosc = 0,2us

#define UP     PORTBbits.RB7
#define DOWN   PORTBbits.RB6
#define SELECT PORTBbits.RB5

//variáveis globais
unsigned char opcao; //variável global para destacar opção correspondente do menu

const unsigned char imagem[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x80, 0xC0, 0xC0, 0x40, 0x60, 0xE0, 0x60, 0xF0, 0x70, 0x30, 0x18, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0x60, 0xE0, 0xA0, 0xB0, 0x70, 0x50, 0xD8, 0xF8, 0xA8, 0xEC, 0xFC, 0xFC,
0x5E, 0x60, 0x60, 0xA0, 0xF0, 0xF0, 0x98, 0x80, 0xC0, 0xC0, 0xC0, 0x60, 0x60, 0xF0, 0x3E, 0xA6,
0xB3, 0xB7, 0x95, 0xFD, 0x7D, 0x0F, 0xC6, 0xFE, 0x3D, 0x0D, 0x0F, 0x07, 0x07, 0x07, 0x06, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xF0, 0xFC, 0x87, 0xF9, 0xB6, 0xAC, 0xAF, 0xBE, 0x36, 0x17, 0x17, 0x87, 0xFF, 0xF9,
0x3F, 0x86, 0xFA, 0x3F, 0x17, 0x82, 0x9B, 0x1B, 0x49, 0xF1, 0x1F, 0x01, 0x36, 0xB6, 0x92, 0xFE,
0xBF, 0xC3, 0xC8, 0xC9, 0xCD, 0x67, 0x7F, 0xE3, 0xB0, 0xB0, 0xFF, 0xD3, 0xD0, 0xD8, 0xF8, 0x68,
0x2C, 0xFC, 0xFC, 0xFE, 0x8E, 0xEA, 0x7B, 0x3B, 0xFF, 0xFD, 0xED, 0xEF, 0xFE, 0xBE, 0xFE, 0x7D,
0xEF, 0xFF, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
0x30, 0xB0, 0xF8, 0x78, 0x08, 0x0C, 0x0C, 0x05, 0x87, 0x87, 0xC3, 0xC3, 0x61, 0x60, 0xF0, 0xB8,
0xBE, 0xBF, 0xFF, 0xD9, 0xDC, 0xFF, 0xEF, 0xAD, 0xAC, 0xFF, 0xF7, 0xD6, 0xDF, 0xFB, 0xFB, 0x6B,
0xEF, 0xBD, 0xBD, 0xB5, 0xF7, 0xFA, 0x1F, 0xDF, 0xF9, 0xFA, 0x1F, 0xED, 0xFD, 0x0F, 0xE3, 0xFF,
0x2E, 0xDF, 0x6B, 0x6B, 0x7B, 0xB7, 0xFD, 0x1D, 0x2F, 0x11, 0x8B, 0x9F, 0x97, 0x17, 0x0B, 0x2D,
0x76, 0xF7, 0x9B, 0x1E, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x10, 0x18, 0x0C, 0x0E, 0x0F, 0x05, 0x06, 0x06, 0x02, 0x37, 0x1F, 0x1F, 0x1F, 0x1F, 0x0A, 0x0D,
0x8D, 0xCF, 0xFF, 0xBE, 0xDE, 0xC7, 0x07, 0x09, 0xC7, 0xE6, 0x6B, 0xE3, 0xE3, 0x3F, 0x07, 0xFA,
0x1F, 0x23, 0x7C, 0x6F, 0x26, 0x06, 0xE3, 0x7B, 0x0F, 0xC0, 0xF2, 0x71, 0x81, 0xC1, 0x7E, 0x07,
0xC0, 0xFE, 0x9F, 0x83, 0x88, 0x8C, 0xCC, 0xCC, 0xC6, 0xF7, 0x1F, 0x81, 0x80, 0xF0, 0x7F, 0x03,
0x07, 0x1C, 0x30, 0x60, 0xC0, 0x80, 0x81, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0xC3, 0xFB,
0x3B, 0x0F, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x21, 0x1C, 0x1F, 0x0C, 0x0C, 0x0C, 0x1F, 0x01, 0x08, 0x0F,
0x07, 0x06, 0x07, 0x03, 0x06, 0x06, 0x06, 0x02, 0x02, 0x07, 0x07, 0x06, 0x06, 0x03, 0x01, 0x01,
0x0F, 0x0F, 0x06, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x03, 0x01,
0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x02, 0x06,
0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00
};

//protótipos de funções
void Inic_Regs(void);
void escreve_menu(void);

void main(void)
{
    Inic_Regs(); //configuração dos PORTS
    Inicializa_SPI(SPI_MM_FOSC_64, MODE_01, SMP_END);
    /*
     * SPI: modo mestre com clock = Fosc/16 = 20MHz/16 = 1,25MHz, 
     * transmissão ocorre na borda de desida e dado é amostrado no final
     */
    Inicializa_5110(); //inicializa o display Nokia 
    
    limpa_display();  //limpa o display
    _BL = 1;          //liga o black light
    __delay_ms(1000);
    _BL = 0;          //liga o black light
    __delay_ms(1000);
    _BL = 1;          //liga o black light
    __delay_ms(1000);
    
    //posiciona o cursor na primeira linha da primeira coluna
    coordenada_x(0x00);
    coordenada_y(0x00);  
    
    testa_display();      //liga todos os pixels do display
    __delay_ms(1000);
    limpa_display();      //limpa a tela do display
    __delay_ms(1000);
    testa_caracteres();   //imprime os caracteres de '0' até '9', de 'A' até 'Z' e de 'a' e até 'z'
    __delay_ms(1000);
    modo_inverso_video(); //modo de exibição de vídeo inverso
    __delay_ms(1000);
    modo_normal_video();        //modo de exibição de vídeo normal
    __delay_ms(1000);
    
    limpa_display();
    __delay_ms(10);    
    cursor_inicio();
    escreve_string("teste");
    coordenada_xy(0x00, 0x01);
    escreve_string("(((TESTE)))");
    __delay_ms(1000);
    
    limpa_display();
    __delay_ms(10);
    cursor_inicio();
    escreve_string_cor("teste", WHITE);
    coordenada_xy(0x00, 0x01);
    escreve_string_cor("(((TESTE)))", WHITE);
    __delay_ms(1000);
            
    limpa_display();
    __delay_ms(10);
    cursor_inicio();
    modo_normal_video();
    __delay_ms(10);
    imprime_imagem(imagem);
    __delay_ms(1000);
    modo_inverso_video();
    __delay_ms(1000);
    modo_normal_video();
    __delay_ms(1000);        

    limpa_display();
    __delay_ms(10);    
    desenha_linha_horizontal(0, 5);
    __delay_ms(10);    
    desenha_linha_vertical(3, 0);
    __delay_ms(10);
    
    posiciona_cursor(1, 1);
    escreve_caractere('A');
    __delay_ms(10);     
    posiciona_cursor(2, 2);
    escreve_caractere('A');
    __delay_ms(10);   
    posiciona_cursor(3, 3);
    escreve_caractere('A');
    __delay_ms(10);    
    posiciona_cursor(1, 4);
    escreve_string("Teste");
    __delay_ms(10);    
    posiciona_cursor(2, 5);
    escreve_string("Teste");
    __delay_ms(10);    
    posiciona_cursor(3, 6);
    escreve_string("Teste");
    __delay_ms(1000);
    
    limpa_display();
    
    TRISDbits.TRISD2 = 0;
    PORTDbits.RD2 = 1;
    //unsigned char pisca = 3;
    
    opcao = 3;  //inicializa variável de controle do menu
    while(1)    //loop infinito
    {
//        while(pisca)
//        {
//            PORTDbits.RD2 = 1;
//            __delay_ms(1000);
//            PORTDbits.RD2 = 0;
//            __delay_ms(1000);
//            pisca--;
//        }
//        pisca = 3;
        
        escreve_menu();
        //__delay_ms(10);
        if(UP == 1)
        {
            while(UP);
            _delay(50000);
            opcao--;      
        }
        if(DOWN == 1)
        {
            while(DOWN);
            _delay(50000);
            opcao++;      
        }
        if(opcao == 2) opcao = 6;
        if(opcao == 7) opcao = 3;        
    }    
    return;
}

/* Esta função inicializa os registradores dos PORTs */
void Inic_Regs(void)
{
    TRISA = 0x00;  //configura todo o PORTA como saída
    TRISB = 0xE0;  //configura todo o PORTB como saída
    TRISC = 0x00;  //configura todo o PORTC como saída
    TRISD = 0x00;  //configura todo o PORTD como saída
    TRISE = 0x00;  //configura todo o PORTE como saída
    ADCON1 = 0x0F; //configura todos os pinos do canal analógico como I/O digital
    PORTA = 0;     //coloca todo o PORTA em nível baixo
    PORTB = 0;     //coloca todo o PORTB em nível baixo
    PORTC = 0;     //coloca todo o PORTC em nível baixo
    PORTD = 0;     //coloca todo o PORTD em nível baixo
    PORTE = 0;     //coloca todo o PORTE em nível baixo
}

/* Esta função escreve um menu na tela do display */
void escreve_menu(void){
    cursor_inicio();
    posiciona_cursor(6, 1);
    escreve_string("MENU");
    desenha_linha_horizontal(0, 1);
    posiciona_cursor(1, 3);
    if(opcao == 3) escreve_string_cor("Opcao 1:", WHITE);
    else escreve_string("Opcao 1:");
    posiciona_cursor(1, 4);
    if(opcao == 4) escreve_string_cor("Opcao 2:", WHITE);
    else escreve_string("Opcao 2:");
    posiciona_cursor(1, 5);
    if(opcao == 5) escreve_string_cor("Opcao 3:", WHITE);
    else escreve_string("Opcao 3:");
    posiciona_cursor(1, 6);
    if(opcao == 6) escreve_string_cor("Opcao 4:", WHITE);
    else escreve_string("Opcao 4:");
}
